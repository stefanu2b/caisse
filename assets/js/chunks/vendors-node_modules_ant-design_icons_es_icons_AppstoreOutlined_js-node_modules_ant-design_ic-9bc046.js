(self["webpackChunkdd_woocommerce_multipos"] = self["webpackChunkdd_woocommerce_multipos"] || []).push([["vendors-node_modules_ant-design_icons_es_icons_AppstoreOutlined_js-node_modules_ant-design_ic-9bc046"],{

/***/ "./node_modules/@ant-design/icons-svg/es/asn/AppstoreOutlined.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@ant-design/icons-svg/es/asn/AppstoreOutlined.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// This icon file is generated automatically.
var AppstoreOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M464 144H160c-8.8 0-16 7.2-16 16v304c0 8.8 7.2 16 16 16h304c8.8 0 16-7.2 16-16V160c0-8.8-7.2-16-16-16zm-52 268H212V212h200v200zm452-268H560c-8.8 0-16 7.2-16 16v304c0 8.8 7.2 16 16 16h304c8.8 0 16-7.2 16-16V160c0-8.8-7.2-16-16-16zm-52 268H612V212h200v200zM464 544H160c-8.8 0-16 7.2-16 16v304c0 8.8 7.2 16 16 16h304c8.8 0 16-7.2 16-16V560c0-8.8-7.2-16-16-16zm-52 268H212V612h200v200zm452-268H560c-8.8 0-16 7.2-16 16v304c0 8.8 7.2 16 16 16h304c8.8 0 16-7.2 16-16V560c0-8.8-7.2-16-16-16zm-52 268H612V612h200v200z" } }] }, "name": "appstore", "theme": "outlined" };
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AppstoreOutlined);


/***/ }),

/***/ "./node_modules/@ant-design/icons-svg/es/asn/BarcodeOutlined.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ant-design/icons-svg/es/asn/BarcodeOutlined.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// This icon file is generated automatically.
var BarcodeOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M120 160H72c-4.4 0-8 3.6-8 8v688c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V168c0-4.4-3.6-8-8-8zm833 0h-48c-4.4 0-8 3.6-8 8v688c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V168c0-4.4-3.6-8-8-8zM200 736h112c4.4 0 8-3.6 8-8V168c0-4.4-3.6-8-8-8H200c-4.4 0-8 3.6-8 8v560c0 4.4 3.6 8 8 8zm321 0h48c4.4 0 8-3.6 8-8V168c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v560c0 4.4 3.6 8 8 8zm126 0h178c4.4 0 8-3.6 8-8V168c0-4.4-3.6-8-8-8H647c-4.4 0-8 3.6-8 8v560c0 4.4 3.6 8 8 8zm-255 0h48c4.4 0 8-3.6 8-8V168c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v560c0 4.4 3.6 8 8 8zm-79 64H201c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h112c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zm257 0h-48c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zm256 0H648c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h178c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zm-385 0h-48c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8z" } }] }, "name": "barcode", "theme": "outlined" };
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BarcodeOutlined);


/***/ }),

/***/ "./node_modules/@ant-design/icons-svg/es/asn/DatabaseOutlined.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@ant-design/icons-svg/es/asn/DatabaseOutlined.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// This icon file is generated automatically.
var DatabaseOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M832 64H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V96c0-17.7-14.3-32-32-32zm-600 72h560v208H232V136zm560 480H232V408h560v208zm0 272H232V680h560v208zM304 240a40 40 0 1080 0 40 40 0 10-80 0zm0 272a40 40 0 1080 0 40 40 0 10-80 0zm0 272a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, "name": "database", "theme": "outlined" };
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DatabaseOutlined);


/***/ }),

/***/ "./node_modules/@ant-design/icons-svg/es/asn/ExclamationCircleOutlined.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@ant-design/icons-svg/es/asn/ExclamationCircleOutlined.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// This icon file is generated automatically.
var ExclamationCircleOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z" } }] }, "name": "exclamation-circle", "theme": "outlined" };
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExclamationCircleOutlined);


/***/ }),

/***/ "./node_modules/@ant-design/icons/es/icons/AppstoreOutlined.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ant-design/icons/es/icons/AppstoreOutlined.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ant_design_icons_svg_es_asn_AppstoreOutlined__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ant-design/icons-svg/es/asn/AppstoreOutlined */ "./node_modules/@ant-design/icons-svg/es/asn/AppstoreOutlined.js");
/* harmony import */ var _components_AntdIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/AntdIcon */ "./node_modules/@ant-design/icons/es/components/AntdIcon.js");
// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY




var AppstoreOutlined = function AppstoreOutlined(props, ref) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_AntdIcon__WEBPACK_IMPORTED_MODULE_1__.default, Object.assign({}, props, {
    ref: ref,
    icon: _ant_design_icons_svg_es_asn_AppstoreOutlined__WEBPACK_IMPORTED_MODULE_2__.default
  }));
};

AppstoreOutlined.displayName = 'AppstoreOutlined';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(AppstoreOutlined));

/***/ }),

/***/ "./node_modules/@ant-design/icons/es/icons/BarcodeOutlined.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ant-design/icons/es/icons/BarcodeOutlined.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ant_design_icons_svg_es_asn_BarcodeOutlined__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ant-design/icons-svg/es/asn/BarcodeOutlined */ "./node_modules/@ant-design/icons-svg/es/asn/BarcodeOutlined.js");
/* harmony import */ var _components_AntdIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/AntdIcon */ "./node_modules/@ant-design/icons/es/components/AntdIcon.js");
// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY




var BarcodeOutlined = function BarcodeOutlined(props, ref) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_AntdIcon__WEBPACK_IMPORTED_MODULE_1__.default, Object.assign({}, props, {
    ref: ref,
    icon: _ant_design_icons_svg_es_asn_BarcodeOutlined__WEBPACK_IMPORTED_MODULE_2__.default
  }));
};

BarcodeOutlined.displayName = 'BarcodeOutlined';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(BarcodeOutlined));

/***/ }),

/***/ "./node_modules/@ant-design/icons/es/icons/DatabaseOutlined.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ant-design/icons/es/icons/DatabaseOutlined.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ant_design_icons_svg_es_asn_DatabaseOutlined__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ant-design/icons-svg/es/asn/DatabaseOutlined */ "./node_modules/@ant-design/icons-svg/es/asn/DatabaseOutlined.js");
/* harmony import */ var _components_AntdIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/AntdIcon */ "./node_modules/@ant-design/icons/es/components/AntdIcon.js");
// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY




var DatabaseOutlined = function DatabaseOutlined(props, ref) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_AntdIcon__WEBPACK_IMPORTED_MODULE_1__.default, Object.assign({}, props, {
    ref: ref,
    icon: _ant_design_icons_svg_es_asn_DatabaseOutlined__WEBPACK_IMPORTED_MODULE_2__.default
  }));
};

DatabaseOutlined.displayName = 'DatabaseOutlined';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(DatabaseOutlined));

/***/ }),

/***/ "./node_modules/@ant-design/icons/es/icons/ExclamationCircleOutlined.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@ant-design/icons/es/icons/ExclamationCircleOutlined.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ant_design_icons_svg_es_asn_ExclamationCircleOutlined__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ant-design/icons-svg/es/asn/ExclamationCircleOutlined */ "./node_modules/@ant-design/icons-svg/es/asn/ExclamationCircleOutlined.js");
/* harmony import */ var _components_AntdIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/AntdIcon */ "./node_modules/@ant-design/icons/es/components/AntdIcon.js");
// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY




var ExclamationCircleOutlined = function ExclamationCircleOutlined(props, ref) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_AntdIcon__WEBPACK_IMPORTED_MODULE_1__.default, Object.assign({}, props, {
    ref: ref,
    icon: _ant_design_icons_svg_es_asn_ExclamationCircleOutlined__WEBPACK_IMPORTED_MODULE_2__.default
  }));
};

ExclamationCircleOutlined.displayName = 'ExclamationCircleOutlined';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(ExclamationCircleOutlined));

/***/ }),

/***/ "./node_modules/react-lazyload/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/react-lazyload/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.forceVisible = exports.forceCheck = exports.lazyload = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _event = __webpack_require__(/*! ./utils/event */ "./node_modules/react-lazyload/lib/utils/event.js");

var _scrollParent = __webpack_require__(/*! ./utils/scrollParent */ "./node_modules/react-lazyload/lib/utils/scrollParent.js");

var _scrollParent2 = _interopRequireDefault(_scrollParent);

var _debounce = __webpack_require__(/*! ./utils/debounce */ "./node_modules/react-lazyload/lib/utils/debounce.js");

var _debounce2 = _interopRequireDefault(_debounce);

var _throttle = __webpack_require__(/*! ./utils/throttle */ "./node_modules/react-lazyload/lib/utils/throttle.js");

var _throttle2 = _interopRequireDefault(_throttle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * react-lazyload
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


var defaultBoundingClientRect = { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
var LISTEN_FLAG = 'data-lazyload-listened';
var listeners = [];
var pending = [];

// try to handle passive events
var passiveEventSupported = false;
try {
  var opts = Object.defineProperty({}, 'passive', {
    get: function get() {
      passiveEventSupported = true;
    }
  });
  window.addEventListener('test', null, opts);
} catch (e) {}
// if they are supported, setup the optional params
// IMPORTANT: FALSE doubles as the default CAPTURE value!
var passiveEvent = passiveEventSupported ? { capture: false, passive: true } : false;

/**
 * Check if `component` is visible in overflow container `parent`
 * @param  {node} component React component
 * @param  {node} parent    component's scroll parent
 * @return {bool}
 */
var checkOverflowVisible = function checkOverflowVisible(component, parent) {
  var node = _reactDom2.default.findDOMNode(component);
  // const node = component.ref;

  var parentTop = void 0;
  var parentLeft = void 0;
  var parentHeight = void 0;
  var parentWidth = void 0;

  try {
    var _parent$getBoundingCl = parent.getBoundingClientRect();

    parentTop = _parent$getBoundingCl.top;
    parentLeft = _parent$getBoundingCl.left;
    parentHeight = _parent$getBoundingCl.height;
    parentWidth = _parent$getBoundingCl.width;
  } catch (e) {
    parentTop = defaultBoundingClientRect.top;
    parentLeft = defaultBoundingClientRect.left;
    parentHeight = defaultBoundingClientRect.height;
    parentWidth = defaultBoundingClientRect.width;
  }

  var windowInnerHeight = window.innerHeight || document.documentElement.clientHeight;
  var windowInnerWidth = window.innerWidth || document.documentElement.clientWidth;

  // calculate top and height of the intersection of the element's scrollParent and viewport
  var intersectionTop = Math.max(parentTop, 0); // intersection's top relative to viewport
  var intersectionLeft = Math.max(parentLeft, 0); // intersection's left relative to viewport
  var intersectionHeight = Math.min(windowInnerHeight, parentTop + parentHeight) - intersectionTop; // height
  var intersectionWidth = Math.min(windowInnerWidth, parentLeft + parentWidth) - intersectionLeft; // width

  // check whether the element is visible in the intersection
  var top = void 0;
  var left = void 0;
  var height = void 0;
  var width = void 0;

  try {
    var _node$getBoundingClie = node.getBoundingClientRect();

    top = _node$getBoundingClie.top;
    left = _node$getBoundingClie.left;
    height = _node$getBoundingClie.height;
    width = _node$getBoundingClie.width;
  } catch (e) {
    top = defaultBoundingClientRect.top;
    left = defaultBoundingClientRect.left;
    height = defaultBoundingClientRect.height;
    width = defaultBoundingClientRect.width;
  }

  var offsetTop = top - intersectionTop; // element's top relative to intersection
  var offsetLeft = left - intersectionLeft; // element's left relative to intersection

  var offsets = Array.isArray(component.props.offset) ? component.props.offset : [component.props.offset, component.props.offset]; // Be compatible with previous API

  return offsetTop - offsets[0] <= intersectionHeight && offsetTop + height + offsets[1] >= 0 && offsetLeft - offsets[0] <= intersectionWidth && offsetLeft + width + offsets[1] >= 0;
};

/**
 * Check if `component` is visible in document
 * @param  {node} component React component
 * @return {bool}
 */
var checkNormalVisible = function checkNormalVisible(component) {
  var node = _reactDom2.default.findDOMNode(component);
  // const node = component.ref;

  // If this element is hidden by css rules somehow, it's definitely invisible
  if (!(node.offsetWidth || node.offsetHeight || node.getClientRects().length)) return false;

  var top = void 0;
  var elementHeight = void 0;

  try {
    var _node$getBoundingClie2 = node.getBoundingClientRect();

    top = _node$getBoundingClie2.top;
    elementHeight = _node$getBoundingClie2.height;
  } catch (e) {
    top = defaultBoundingClientRect.top;
    elementHeight = defaultBoundingClientRect.height;
  }

  var windowInnerHeight = window.innerHeight || document.documentElement.clientHeight;

  var offsets = Array.isArray(component.props.offset) ? component.props.offset : [component.props.offset, component.props.offset]; // Be compatible with previous API

  return top - offsets[0] <= windowInnerHeight && top + elementHeight + offsets[1] >= 0;
};

/**
 * Detect if element is visible in viewport, if so, set `visible` state to true.
 * If `once` prop is provided true, remove component as listener after checkVisible
 *
 * @param  {React} component   React component that respond to scroll and resize
 */
var checkVisible = function checkVisible(component) {
  var node = _reactDom2.default.findDOMNode(component);
  // const node = component.ref;
  if (!(node instanceof HTMLElement)) {
    return;
  }

  var parent = (0, _scrollParent2.default)(node);
  var isOverflow = component.props.overflow && parent !== node.ownerDocument && parent !== document && parent !== document.documentElement;
  var visible = isOverflow ? checkOverflowVisible(component, parent) : checkNormalVisible(component);
  if (visible) {
    // Avoid extra render if previously is visible
    if (!component.visible) {
      if (component.props.once) {
        pending.push(component);
      }

      component.visible = true;
      component.forceUpdate();
    }
  } else if (!(component.props.once && component.visible)) {
    component.visible = false;
    if (component.props.unmountIfInvisible) {
      component.forceUpdate();
    }
  }
};

var purgePending = function purgePending() {
  pending.forEach(function (component) {
    var index = listeners.indexOf(component);
    if (index !== -1) {
      listeners.splice(index, 1);
    }
  });

  pending = [];
};

var lazyLoadHandler = function lazyLoadHandler() {
  for (var i = 0; i < listeners.length; ++i) {
    var listener = listeners[i];
    checkVisible(listener);
  }
  // Remove `once` component in listeners
  purgePending();
};

/**
 * Forces the component to display regardless of whether the element is visible in the viewport.
 */
var forceVisible = function forceVisible() {
  for (var i = 0; i < listeners.length; ++i) {
    var listener = listeners[i];
    listener.visible = true;
    listener.forceUpdate();
  }
  // Remove `once` component in listeners
  purgePending();
};

// Depending on component's props
var delayType = void 0;
var finalLazyLoadHandler = null;

var isString = function isString(string) {
  return typeof string === 'string';
};

var LazyLoad = function (_Component) {
  _inherits(LazyLoad, _Component);

  function LazyLoad(props) {
    _classCallCheck(this, LazyLoad);

    var _this = _possibleConstructorReturn(this, (LazyLoad.__proto__ || Object.getPrototypeOf(LazyLoad)).call(this, props));

    _this.visible = false;
    // this.setRef = this.setRef.bind(this);
    return _this;
  }

  // setRef(element) {
  //   if (element) {
  //     this.ref = element;
  //   }
  // }

  _createClass(LazyLoad, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      // It's unlikely to change delay type on the fly, this is mainly
      // designed for tests
      var scrollport = window;
      var scrollContainer = this.props.scrollContainer;

      if (scrollContainer) {
        if (isString(scrollContainer)) {
          scrollport = scrollport.document.querySelector(scrollContainer);
        }
      }
      var needResetFinalLazyLoadHandler = this.props.debounce !== undefined && delayType === 'throttle' || delayType === 'debounce' && this.props.debounce === undefined;

      if (needResetFinalLazyLoadHandler) {
        (0, _event.off)(scrollport, 'scroll', finalLazyLoadHandler, passiveEvent);
        (0, _event.off)(window, 'resize', finalLazyLoadHandler, passiveEvent);
        finalLazyLoadHandler = null;
      }

      if (!finalLazyLoadHandler) {
        if (this.props.debounce !== undefined) {
          finalLazyLoadHandler = (0, _debounce2.default)(lazyLoadHandler, typeof this.props.debounce === 'number' ? this.props.debounce : 300);
          delayType = 'debounce';
        } else if (this.props.throttle !== undefined) {
          finalLazyLoadHandler = (0, _throttle2.default)(lazyLoadHandler, typeof this.props.throttle === 'number' ? this.props.throttle : 300);
          delayType = 'throttle';
        } else {
          finalLazyLoadHandler = lazyLoadHandler;
        }
      }

      if (this.props.overflow) {
        var parent = (0, _scrollParent2.default)(_reactDom2.default.findDOMNode(this));
        // const parent = scrollParent(this.ref);
        if (parent && typeof parent.getAttribute === 'function') {
          var listenerCount = 1 + +parent.getAttribute(LISTEN_FLAG);
          if (listenerCount === 1) {
            parent.addEventListener('scroll', finalLazyLoadHandler, passiveEvent);
          }
          parent.setAttribute(LISTEN_FLAG, listenerCount);
        }
      } else if (listeners.length === 0 || needResetFinalLazyLoadHandler) {
        var _props = this.props,
            scroll = _props.scroll,
            resize = _props.resize;


        if (scroll) {
          (0, _event.on)(scrollport, 'scroll', finalLazyLoadHandler, passiveEvent);
        }

        if (resize) {
          (0, _event.on)(window, 'resize', finalLazyLoadHandler, passiveEvent);
        }
      }

      listeners.push(this);
      checkVisible(this);
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate() {
      return this.visible;
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.props.overflow) {
        var parent = (0, _scrollParent2.default)(_reactDom2.default.findDOMNode(this));
        // const parent = scrollParent(this.ref);
        if (parent && typeof parent.getAttribute === 'function') {
          var listenerCount = +parent.getAttribute(LISTEN_FLAG) - 1;
          if (listenerCount === 0) {
            parent.removeEventListener('scroll', finalLazyLoadHandler, passiveEvent);
            parent.removeAttribute(LISTEN_FLAG);
          } else {
            parent.setAttribute(LISTEN_FLAG, listenerCount);
          }
        }
      }

      var index = listeners.indexOf(this);
      if (index !== -1) {
        listeners.splice(index, 1);
      }

      if (listeners.length === 0 && typeof window !== 'undefined') {
        (0, _event.off)(window, 'resize', finalLazyLoadHandler, passiveEvent);
        (0, _event.off)(window, 'scroll', finalLazyLoadHandler, passiveEvent);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return this.visible ? this.props.children : this.props.placeholder ? this.props.placeholder : _react2.default.createElement('div', { style: { height: this.props.height }, className: 'lazyload-placeholder' });
      // <span ref={this.setRef} className="lazyload-custom-placeholder">
      //   {this.props.placeholder}
      // </span> :
      // <div ref={this.setRef} style={{ height: this.props.height }} className="lazyload-placeholder" />;
    }
  }]);

  return LazyLoad;
}(_react.Component);

LazyLoad.propTypes = {
  once: _propTypes2.default.bool,
  height: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
  offset: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.arrayOf(_propTypes2.default.number)]),
  overflow: _propTypes2.default.bool,
  resize: _propTypes2.default.bool,
  scroll: _propTypes2.default.bool,
  children: _propTypes2.default.node,
  throttle: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.bool]),
  debounce: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.bool]),
  placeholder: _propTypes2.default.node,
  scrollContainer: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),
  unmountIfInvisible: _propTypes2.default.bool
};

LazyLoad.defaultProps = {
  once: false,
  offset: 0,
  overflow: false,
  resize: false,
  scroll: true,
  unmountIfInvisible: false
};

var getDisplayName = function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
};

var decorator = function decorator() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function lazyload(WrappedComponent) {
    return function (_Component2) {
      _inherits(LazyLoadDecorated, _Component2);

      function LazyLoadDecorated() {
        _classCallCheck(this, LazyLoadDecorated);

        var _this2 = _possibleConstructorReturn(this, (LazyLoadDecorated.__proto__ || Object.getPrototypeOf(LazyLoadDecorated)).call(this));

        _this2.displayName = 'LazyLoad' + getDisplayName(WrappedComponent);
        return _this2;
      }

      _createClass(LazyLoadDecorated, [{
        key: 'render',
        value: function render() {
          return _react2.default.createElement(
            LazyLoad,
            options,
            _react2.default.createElement(WrappedComponent, this.props)
          );
        }
      }]);

      return LazyLoadDecorated;
    }(_react.Component);
  };
};

exports.lazyload = decorator;
exports.default = LazyLoad;
exports.forceCheck = lazyLoadHandler;
exports.forceVisible = forceVisible;

/***/ }),

/***/ "./node_modules/react-lazyload/lib/utils/debounce.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-lazyload/lib/utils/debounce.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = debounce;
function debounce(func, wait, immediate) {
  var timeout = void 0;
  var args = void 0;
  var context = void 0;
  var timestamp = void 0;
  var result = void 0;

  var later = function later() {
    var last = +new Date() - timestamp;

    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        if (!timeout) {
          context = null;
          args = null;
        }
      }
    }
  };

  return function debounced() {
    context = this;
    args = arguments;
    timestamp = +new Date();

    var callNow = immediate && !timeout;
    if (!timeout) {
      timeout = setTimeout(later, wait);
    }

    if (callNow) {
      result = func.apply(context, args);
      context = null;
      args = null;
    }

    return result;
  };
}

/***/ }),

/***/ "./node_modules/react-lazyload/lib/utils/event.js":
/*!********************************************************!*\
  !*** ./node_modules/react-lazyload/lib/utils/event.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.on = on;
exports.off = off;
function on(el, eventName, callback, opts) {
  opts = opts || false;
  if (el.addEventListener) {
    el.addEventListener(eventName, callback, opts);
  } else if (el.attachEvent) {
    el.attachEvent("on" + eventName, function (e) {
      callback.call(el, e || window.event);
    });
  }
}

function off(el, eventName, callback, opts) {
  opts = opts || false;
  if (el.removeEventListener) {
    el.removeEventListener(eventName, callback, opts);
  } else if (el.detachEvent) {
    el.detachEvent("on" + eventName, callback);
  }
}

/***/ }),

/***/ "./node_modules/react-lazyload/lib/utils/scrollParent.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-lazyload/lib/utils/scrollParent.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/**
 * @fileOverview Find scroll parent
 */

exports.default = function (node) {
  if (!(node instanceof HTMLElement)) {
    return document.documentElement;
  }

  var excludeStaticParent = node.style.position === 'absolute';
  var overflowRegex = /(scroll|auto)/;
  var parent = node;

  while (parent) {
    if (!parent.parentNode) {
      return node.ownerDocument || document.documentElement;
    }

    var style = window.getComputedStyle(parent);
    var position = style.position;
    var overflow = style.overflow;
    var overflowX = style['overflow-x'];
    var overflowY = style['overflow-y'];

    if (position === 'static' && excludeStaticParent) {
      parent = parent.parentNode;
      continue;
    }

    if (overflowRegex.test(overflow) && overflowRegex.test(overflowX) && overflowRegex.test(overflowY)) {
      return parent;
    }

    parent = parent.parentNode;
  }

  return node.ownerDocument || node.documentElement || document.documentElement;
};

/***/ }),

/***/ "./node_modules/react-lazyload/lib/utils/throttle.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-lazyload/lib/utils/throttle.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = throttle;
/*eslint-disable */
function throttle(fn, threshhold, scope) {
  threshhold || (threshhold = 250);
  var last, deferTimer;
  return function () {
    var context = scope || this;

    var now = +new Date(),
        args = arguments;
    if (last && now < last + threshhold) {
      // hold on to it
      clearTimeout(deferTimer);
      deferTimer = setTimeout(function () {
        last = now;
        fn.apply(context, args);
      }, threshhold);
    } else {
      last = now;
      fn.apply(context, args);
    }
  };
}

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZC13b29jb21tZXJjZS1tdWx0aXBvcy8uL25vZGVfbW9kdWxlcy9AYW50LWRlc2lnbi9pY29ucy1zdmcvZXMvYXNuL0FwcHN0b3JlT3V0bGluZWQuanMiLCJ3ZWJwYWNrOi8vZGQtd29vY29tbWVyY2UtbXVsdGlwb3MvLi9ub2RlX21vZHVsZXMvQGFudC1kZXNpZ24vaWNvbnMtc3ZnL2VzL2Fzbi9CYXJjb2RlT3V0bGluZWQuanMiLCJ3ZWJwYWNrOi8vZGQtd29vY29tbWVyY2UtbXVsdGlwb3MvLi9ub2RlX21vZHVsZXMvQGFudC1kZXNpZ24vaWNvbnMtc3ZnL2VzL2Fzbi9EYXRhYmFzZU91dGxpbmVkLmpzIiwid2VicGFjazovL2RkLXdvb2NvbW1lcmNlLW11bHRpcG9zLy4vbm9kZV9tb2R1bGVzL0BhbnQtZGVzaWduL2ljb25zLXN2Zy9lcy9hc24vRXhjbGFtYXRpb25DaXJjbGVPdXRsaW5lZC5qcyIsIndlYnBhY2s6Ly9kZC13b29jb21tZXJjZS1tdWx0aXBvcy8uL25vZGVfbW9kdWxlcy9AYW50LWRlc2lnbi9pY29ucy9lcy9pY29ucy9BcHBzdG9yZU91dGxpbmVkLmpzIiwid2VicGFjazovL2RkLXdvb2NvbW1lcmNlLW11bHRpcG9zLy4vbm9kZV9tb2R1bGVzL0BhbnQtZGVzaWduL2ljb25zL2VzL2ljb25zL0JhcmNvZGVPdXRsaW5lZC5qcyIsIndlYnBhY2s6Ly9kZC13b29jb21tZXJjZS1tdWx0aXBvcy8uL25vZGVfbW9kdWxlcy9AYW50LWRlc2lnbi9pY29ucy9lcy9pY29ucy9EYXRhYmFzZU91dGxpbmVkLmpzIiwid2VicGFjazovL2RkLXdvb2NvbW1lcmNlLW11bHRpcG9zLy4vbm9kZV9tb2R1bGVzL0BhbnQtZGVzaWduL2ljb25zL2VzL2ljb25zL0V4Y2xhbWF0aW9uQ2lyY2xlT3V0bGluZWQuanMiLCJ3ZWJwYWNrOi8vZGQtd29vY29tbWVyY2UtbXVsdGlwb3MvLi9ub2RlX21vZHVsZXMvcmVhY3QtbGF6eWxvYWQvbGliL2luZGV4LmpzIiwid2VicGFjazovL2RkLXdvb2NvbW1lcmNlLW11bHRpcG9zLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWxhenlsb2FkL2xpYi91dGlscy9kZWJvdW5jZS5qcyIsIndlYnBhY2s6Ly9kZC13b29jb21tZXJjZS1tdWx0aXBvcy8uL25vZGVfbW9kdWxlcy9yZWFjdC1sYXp5bG9hZC9saWIvdXRpbHMvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vZGQtd29vY29tbWVyY2UtbXVsdGlwb3MvLi9ub2RlX21vZHVsZXMvcmVhY3QtbGF6eWxvYWQvbGliL3V0aWxzL3Njcm9sbFBhcmVudC5qcyIsIndlYnBhY2s6Ly9kZC13b29jb21tZXJjZS1tdWx0aXBvcy8uL25vZGVfbW9kdWxlcy9yZWFjdC1sYXp5bG9hZC9saWIvdXRpbHMvdGhyb3R0bGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0Esd0JBQXdCLFVBQVUseUJBQXlCLG1EQUFtRCxnQkFBZ0IsMEJBQTBCLHNnQkFBc2dCLEVBQUUsR0FBRztBQUNucUIsaUVBQWUsZ0JBQWdCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGaEM7QUFDQSx1QkFBdUIsVUFBVSx5QkFBeUIsbURBQW1ELGdCQUFnQiwwQkFBMEIsczNCQUFzM0IsRUFBRSxHQUFHO0FBQ2xoQyxpRUFBZSxlQUFlLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGL0I7QUFDQSx3QkFBd0IsVUFBVSx5QkFBeUIsbURBQW1ELGdCQUFnQiwwQkFBMEIsbVRBQW1ULEVBQUUsR0FBRztBQUNoZCxpRUFBZSxnQkFBZ0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZoQztBQUNBLGlDQUFpQyxVQUFVLHlCQUF5QixtREFBbUQsZ0JBQWdCLDBCQUEwQix1TEFBdUwsRUFBRSxHQUFHLDBCQUEwQiwwSUFBMEksRUFBRSxHQUFHO0FBQ3RnQixpRUFBZSx5QkFBeUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGekM7QUFDQTtBQUMrQjtBQUNpRDtBQUNsQzs7QUFFOUM7QUFDQSxzQkFBc0IsZ0RBQW1CLENBQUMseURBQVEsa0JBQWtCO0FBQ3BFO0FBQ0EsVUFBVSxrRkFBbUI7QUFDN0IsR0FBRztBQUNIOztBQUVBO0FBQ0EsOEVBQTRCLDZDQUFnQixrQkFBa0IsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2Q5RDtBQUNBO0FBQytCO0FBQytDO0FBQ2hDOztBQUU5QztBQUNBLHNCQUFzQixnREFBbUIsQ0FBQyx5REFBUSxrQkFBa0I7QUFDcEU7QUFDQSxVQUFVLGlGQUFrQjtBQUM1QixHQUFHO0FBQ0g7O0FBRUE7QUFDQSw4RUFBNEIsNkNBQWdCLGlCQUFpQixFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZDdEO0FBQ0E7QUFDK0I7QUFDaUQ7QUFDbEM7O0FBRTlDO0FBQ0Esc0JBQXNCLGdEQUFtQixDQUFDLHlEQUFRLGtCQUFrQjtBQUNwRTtBQUNBLFVBQVUsa0ZBQW1CO0FBQzdCLEdBQUc7QUFDSDs7QUFFQTtBQUNBLDhFQUE0Qiw2Q0FBZ0Isa0JBQWtCLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNkOUQ7QUFDQTtBQUMrQjtBQUNtRTtBQUNwRDs7QUFFOUM7QUFDQSxzQkFBc0IsZ0RBQW1CLENBQUMseURBQVEsa0JBQWtCO0FBQ3BFO0FBQ0EsVUFBVSwyRkFBNEI7QUFDdEMsR0FBRztBQUNIOztBQUVBO0FBQ0EsOEVBQTRCLDZDQUFnQiwyQkFBMkIsRTs7Ozs7Ozs7Ozs7QUNkMUQ7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0JBQW9CLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCOztBQUU1RCxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFOztBQUVqakIsYUFBYSxtQkFBTyxDQUFDLG9CQUFPOztBQUU1Qjs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyw0QkFBVzs7QUFFbkM7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsc0RBQVk7O0FBRXJDOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx1RUFBZTs7QUFFcEMsb0JBQW9CLG1CQUFPLENBQUMscUZBQXNCOztBQUVsRDs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyw2RUFBa0I7O0FBRTFDOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLDZFQUFrQjs7QUFFMUM7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLGlEQUFpRCxhQUFhLHVGQUF1RixFQUFFLHVGQUF1Rjs7QUFFOU8sMENBQTBDLCtEQUErRCxxR0FBcUcsRUFBRSx5RUFBeUUsZUFBZSx5RUFBeUUsRUFBRSxFQUFFLHVIQUF1SCxFQUFFO0FBQzllO0FBQ0E7OztBQUdBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsNENBQTRDLGdDQUFnQzs7QUFFNUU7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DLGlEQUFpRDtBQUNqRCxtR0FBbUc7QUFDbkcsa0dBQWtHOztBQUVsRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEMsMkNBQTJDOztBQUUzQyxrSUFBa0k7O0FBRWxJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0lBQWtJOztBQUVsSTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwSUFBMEksU0FBUyw0QkFBNEIscUNBQXFDO0FBQ3BOLG9CQUFvQixZQUFZO0FBQ2hDLFlBQVk7QUFDWjtBQUNBLG1CQUFtQixZQUFZLFNBQVMsNkJBQTZCO0FBQ3JFO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixvQkFBb0IsZ0I7Ozs7Ozs7Ozs7O0FDMWFQOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7O0FDaERhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLFVBQVU7QUFDVixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7OztBQ3pCYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7O0FBRUY7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFOzs7Ozs7Ozs7OztBQzNDYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQyIsImZpbGUiOiIuL2Fzc2V0cy9qcy9jaHVua3MvdmVuZG9ycy1ub2RlX21vZHVsZXNfYW50LWRlc2lnbl9pY29uc19lc19pY29uc19BcHBzdG9yZU91dGxpbmVkX2pzLW5vZGVfbW9kdWxlc19hbnQtZGVzaWduX2ljLTliYzA0Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgaWNvbiBmaWxlIGlzIGdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5LlxudmFyIEFwcHN0b3JlT3V0bGluZWQgPSB7IFwiaWNvblwiOiB7IFwidGFnXCI6IFwic3ZnXCIsIFwiYXR0cnNcIjogeyBcInZpZXdCb3hcIjogXCI2NCA2NCA4OTYgODk2XCIsIFwiZm9jdXNhYmxlXCI6IFwiZmFsc2VcIiB9LCBcImNoaWxkcmVuXCI6IFt7IFwidGFnXCI6IFwicGF0aFwiLCBcImF0dHJzXCI6IHsgXCJkXCI6IFwiTTQ2NCAxNDRIMTYwYy04LjggMC0xNiA3LjItMTYgMTZ2MzA0YzAgOC44IDcuMiAxNiAxNiAxNmgzMDRjOC44IDAgMTYtNy4yIDE2LTE2VjE2MGMwLTguOC03LjItMTYtMTYtMTZ6bS01MiAyNjhIMjEyVjIxMmgyMDB2MjAwem00NTItMjY4SDU2MGMtOC44IDAtMTYgNy4yLTE2IDE2djMwNGMwIDguOCA3LjIgMTYgMTYgMTZoMzA0YzguOCAwIDE2LTcuMiAxNi0xNlYxNjBjMC04LjgtNy4yLTE2LTE2LTE2em0tNTIgMjY4SDYxMlYyMTJoMjAwdjIwMHpNNDY0IDU0NEgxNjBjLTguOCAwLTE2IDcuMi0xNiAxNnYzMDRjMCA4LjggNy4yIDE2IDE2IDE2aDMwNGM4LjggMCAxNi03LjIgMTYtMTZWNTYwYzAtOC44LTcuMi0xNi0xNi0xNnptLTUyIDI2OEgyMTJWNjEyaDIwMHYyMDB6bTQ1Mi0yNjhINTYwYy04LjggMC0xNiA3LjItMTYgMTZ2MzA0YzAgOC44IDcuMiAxNiAxNiAxNmgzMDRjOC44IDAgMTYtNy4yIDE2LTE2VjU2MGMwLTguOC03LjItMTYtMTYtMTZ6bS01MiAyNjhINjEyVjYxMmgyMDB2MjAwelwiIH0gfV0gfSwgXCJuYW1lXCI6IFwiYXBwc3RvcmVcIiwgXCJ0aGVtZVwiOiBcIm91dGxpbmVkXCIgfTtcbmV4cG9ydCBkZWZhdWx0IEFwcHN0b3JlT3V0bGluZWQ7XG4iLCIvLyBUaGlzIGljb24gZmlsZSBpcyBnZW5lcmF0ZWQgYXV0b21hdGljYWxseS5cbnZhciBCYXJjb2RlT3V0bGluZWQgPSB7IFwiaWNvblwiOiB7IFwidGFnXCI6IFwic3ZnXCIsIFwiYXR0cnNcIjogeyBcInZpZXdCb3hcIjogXCI2NCA2NCA4OTYgODk2XCIsIFwiZm9jdXNhYmxlXCI6IFwiZmFsc2VcIiB9LCBcImNoaWxkcmVuXCI6IFt7IFwidGFnXCI6IFwicGF0aFwiLCBcImF0dHJzXCI6IHsgXCJkXCI6IFwiTTEyMCAxNjBINzJjLTQuNCAwLTggMy42LTggOHY2ODhjMCA0LjQgMy42IDggOCA4aDQ4YzQuNCAwIDgtMy42IDgtOFYxNjhjMC00LjQtMy42LTgtOC04em04MzMgMGgtNDhjLTQuNCAwLTggMy42LTggOHY2ODhjMCA0LjQgMy42IDggOCA4aDQ4YzQuNCAwIDgtMy42IDgtOFYxNjhjMC00LjQtMy42LTgtOC04ek0yMDAgNzM2aDExMmM0LjQgMCA4LTMuNiA4LThWMTY4YzAtNC40LTMuNi04LTgtOEgyMDBjLTQuNCAwLTggMy42LTggOHY1NjBjMCA0LjQgMy42IDggOCA4em0zMjEgMGg0OGM0LjQgMCA4LTMuNiA4LThWMTY4YzAtNC40LTMuNi04LTgtOGgtNDhjLTQuNCAwLTggMy42LTggOHY1NjBjMCA0LjQgMy42IDggOCA4em0xMjYgMGgxNzhjNC40IDAgOC0zLjYgOC04VjE2OGMwLTQuNC0zLjYtOC04LThINjQ3Yy00LjQgMC04IDMuNi04IDh2NTYwYzAgNC40IDMuNiA4IDggOHptLTI1NSAwaDQ4YzQuNCAwIDgtMy42IDgtOFYxNjhjMC00LjQtMy42LTgtOC04aC00OGMtNC40IDAtOCAzLjYtOCA4djU2MGMwIDQuNCAzLjYgOCA4IDh6bS03OSA2NEgyMDFjLTQuNCAwLTggMy42LTggOHY0OGMwIDQuNCAzLjYgOCA4IDhoMTEyYzQuNCAwIDgtMy42IDgtOHYtNDhjMC00LjQtMy42LTgtOC04em0yNTcgMGgtNDhjLTQuNCAwLTggMy42LTggOHY0OGMwIDQuNCAzLjYgOCA4IDhoNDhjNC40IDAgOC0zLjYgOC04di00OGMwLTQuNC0zLjYtOC04LTh6bTI1NiAwSDY0OGMtNC40IDAtOCAzLjYtOCA4djQ4YzAgNC40IDMuNiA4IDggOGgxNzhjNC40IDAgOC0zLjYgOC04di00OGMwLTQuNC0zLjYtOC04LTh6bS0zODUgMGgtNDhjLTQuNCAwLTggMy42LTggOHY0OGMwIDQuNCAzLjYgOCA4IDhoNDhjNC40IDAgOC0zLjYgOC04di00OGMwLTQuNC0zLjYtOC04LTh6XCIgfSB9XSB9LCBcIm5hbWVcIjogXCJiYXJjb2RlXCIsIFwidGhlbWVcIjogXCJvdXRsaW5lZFwiIH07XG5leHBvcnQgZGVmYXVsdCBCYXJjb2RlT3V0bGluZWQ7XG4iLCIvLyBUaGlzIGljb24gZmlsZSBpcyBnZW5lcmF0ZWQgYXV0b21hdGljYWxseS5cbnZhciBEYXRhYmFzZU91dGxpbmVkID0geyBcImljb25cIjogeyBcInRhZ1wiOiBcInN2Z1wiLCBcImF0dHJzXCI6IHsgXCJ2aWV3Qm94XCI6IFwiNjQgNjQgODk2IDg5NlwiLCBcImZvY3VzYWJsZVwiOiBcImZhbHNlXCIgfSwgXCJjaGlsZHJlblwiOiBbeyBcInRhZ1wiOiBcInBhdGhcIiwgXCJhdHRyc1wiOiB7IFwiZFwiOiBcIk04MzIgNjRIMTkyYy0xNy43IDAtMzIgMTQuMy0zMiAzMnY4MzJjMCAxNy43IDE0LjMgMzIgMzIgMzJoNjQwYzE3LjcgMCAzMi0xNC4zIDMyLTMyVjk2YzAtMTcuNy0xNC4zLTMyLTMyLTMyem0tNjAwIDcyaDU2MHYyMDhIMjMyVjEzNnptNTYwIDQ4MEgyMzJWNDA4aDU2MHYyMDh6bTAgMjcySDIzMlY2ODBoNTYwdjIwOHpNMzA0IDI0MGE0MCA0MCAwIDEwODAgMCA0MCA0MCAwIDEwLTgwIDB6bTAgMjcyYTQwIDQwIDAgMTA4MCAwIDQwIDQwIDAgMTAtODAgMHptMCAyNzJhNDAgNDAgMCAxMDgwIDAgNDAgNDAgMCAxMC04MCAwelwiIH0gfV0gfSwgXCJuYW1lXCI6IFwiZGF0YWJhc2VcIiwgXCJ0aGVtZVwiOiBcIm91dGxpbmVkXCIgfTtcbmV4cG9ydCBkZWZhdWx0IERhdGFiYXNlT3V0bGluZWQ7XG4iLCIvLyBUaGlzIGljb24gZmlsZSBpcyBnZW5lcmF0ZWQgYXV0b21hdGljYWxseS5cbnZhciBFeGNsYW1hdGlvbkNpcmNsZU91dGxpbmVkID0geyBcImljb25cIjogeyBcInRhZ1wiOiBcInN2Z1wiLCBcImF0dHJzXCI6IHsgXCJ2aWV3Qm94XCI6IFwiNjQgNjQgODk2IDg5NlwiLCBcImZvY3VzYWJsZVwiOiBcImZhbHNlXCIgfSwgXCJjaGlsZHJlblwiOiBbeyBcInRhZ1wiOiBcInBhdGhcIiwgXCJhdHRyc1wiOiB7IFwiZFwiOiBcIk01MTIgNjRDMjY0LjYgNjQgNjQgMjY0LjYgNjQgNTEyczIwMC42IDQ0OCA0NDggNDQ4IDQ0OC0yMDAuNiA0NDgtNDQ4Uzc1OS40IDY0IDUxMiA2NHptMCA4MjBjLTIwNS40IDAtMzcyLTE2Ni42LTM3Mi0zNzJzMTY2LjYtMzcyIDM3Mi0zNzIgMzcyIDE2Ni42IDM3MiAzNzItMTY2LjYgMzcyLTM3MiAzNzJ6XCIgfSB9LCB7IFwidGFnXCI6IFwicGF0aFwiLCBcImF0dHJzXCI6IHsgXCJkXCI6IFwiTTQ2NCA2ODhhNDggNDggMCAxMDk2IDAgNDggNDggMCAxMC05NiAwem0yNC0xMTJoNDhjNC40IDAgOC0zLjYgOC04VjI5NmMwLTQuNC0zLjYtOC04LThoLTQ4Yy00LjQgMC04IDMuNi04IDh2MjcyYzAgNC40IDMuNiA4IDggOHpcIiB9IH1dIH0sIFwibmFtZVwiOiBcImV4Y2xhbWF0aW9uLWNpcmNsZVwiLCBcInRoZW1lXCI6IFwib3V0bGluZWRcIiB9O1xuZXhwb3J0IGRlZmF1bHQgRXhjbGFtYXRpb25DaXJjbGVPdXRsaW5lZDtcbiIsIi8vIEdFTkVSQVRFIEJZIC4vc2NyaXB0cy9nZW5lcmF0ZS50c1xuLy8gRE9OIE5PVCBFRElUIElUIE1BTlVBTExZXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgQXBwc3RvcmVPdXRsaW5lZFN2ZyBmcm9tIFwiQGFudC1kZXNpZ24vaWNvbnMtc3ZnL2VzL2Fzbi9BcHBzdG9yZU91dGxpbmVkXCI7XG5pbXBvcnQgQW50ZEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9BbnRkSWNvbic7XG5cbnZhciBBcHBzdG9yZU91dGxpbmVkID0gZnVuY3Rpb24gQXBwc3RvcmVPdXRsaW5lZChwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnRkSWNvbiwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICByZWY6IHJlZixcbiAgICBpY29uOiBBcHBzdG9yZU91dGxpbmVkU3ZnXG4gIH0pKTtcbn07XG5cbkFwcHN0b3JlT3V0bGluZWQuZGlzcGxheU5hbWUgPSAnQXBwc3RvcmVPdXRsaW5lZCc7XG5leHBvcnQgZGVmYXVsdCAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihBcHBzdG9yZU91dGxpbmVkKTsiLCIvLyBHRU5FUkFURSBCWSAuL3NjcmlwdHMvZ2VuZXJhdGUudHNcbi8vIERPTiBOT1QgRURJVCBJVCBNQU5VQUxMWVxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IEJhcmNvZGVPdXRsaW5lZFN2ZyBmcm9tIFwiQGFudC1kZXNpZ24vaWNvbnMtc3ZnL2VzL2Fzbi9CYXJjb2RlT3V0bGluZWRcIjtcbmltcG9ydCBBbnRkSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0FudGRJY29uJztcblxudmFyIEJhcmNvZGVPdXRsaW5lZCA9IGZ1bmN0aW9uIEJhcmNvZGVPdXRsaW5lZChwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnRkSWNvbiwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICByZWY6IHJlZixcbiAgICBpY29uOiBCYXJjb2RlT3V0bGluZWRTdmdcbiAgfSkpO1xufTtcblxuQmFyY29kZU91dGxpbmVkLmRpc3BsYXlOYW1lID0gJ0JhcmNvZGVPdXRsaW5lZCc7XG5leHBvcnQgZGVmYXVsdCAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihCYXJjb2RlT3V0bGluZWQpOyIsIi8vIEdFTkVSQVRFIEJZIC4vc2NyaXB0cy9nZW5lcmF0ZS50c1xuLy8gRE9OIE5PVCBFRElUIElUIE1BTlVBTExZXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRGF0YWJhc2VPdXRsaW5lZFN2ZyBmcm9tIFwiQGFudC1kZXNpZ24vaWNvbnMtc3ZnL2VzL2Fzbi9EYXRhYmFzZU91dGxpbmVkXCI7XG5pbXBvcnQgQW50ZEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9BbnRkSWNvbic7XG5cbnZhciBEYXRhYmFzZU91dGxpbmVkID0gZnVuY3Rpb24gRGF0YWJhc2VPdXRsaW5lZChwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnRkSWNvbiwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICByZWY6IHJlZixcbiAgICBpY29uOiBEYXRhYmFzZU91dGxpbmVkU3ZnXG4gIH0pKTtcbn07XG5cbkRhdGFiYXNlT3V0bGluZWQuZGlzcGxheU5hbWUgPSAnRGF0YWJhc2VPdXRsaW5lZCc7XG5leHBvcnQgZGVmYXVsdCAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihEYXRhYmFzZU91dGxpbmVkKTsiLCIvLyBHRU5FUkFURSBCWSAuL3NjcmlwdHMvZ2VuZXJhdGUudHNcbi8vIERPTiBOT1QgRURJVCBJVCBNQU5VQUxMWVxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IEV4Y2xhbWF0aW9uQ2lyY2xlT3V0bGluZWRTdmcgZnJvbSBcIkBhbnQtZGVzaWduL2ljb25zLXN2Zy9lcy9hc24vRXhjbGFtYXRpb25DaXJjbGVPdXRsaW5lZFwiO1xuaW1wb3J0IEFudGRJY29uIGZyb20gJy4uL2NvbXBvbmVudHMvQW50ZEljb24nO1xuXG52YXIgRXhjbGFtYXRpb25DaXJjbGVPdXRsaW5lZCA9IGZ1bmN0aW9uIEV4Y2xhbWF0aW9uQ2lyY2xlT3V0bGluZWQocHJvcHMsIHJlZikge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW50ZEljb24sIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgcmVmOiByZWYsXG4gICAgaWNvbjogRXhjbGFtYXRpb25DaXJjbGVPdXRsaW5lZFN2Z1xuICB9KSk7XG59O1xuXG5FeGNsYW1hdGlvbkNpcmNsZU91dGxpbmVkLmRpc3BsYXlOYW1lID0gJ0V4Y2xhbWF0aW9uQ2lyY2xlT3V0bGluZWQnO1xuZXhwb3J0IGRlZmF1bHQgLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoRXhjbGFtYXRpb25DaXJjbGVPdXRsaW5lZCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5mb3JjZVZpc2libGUgPSBleHBvcnRzLmZvcmNlQ2hlY2sgPSBleHBvcnRzLmxhenlsb2FkID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cbnZhciBfcHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpO1xuXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG52YXIgX2V2ZW50ID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpO1xuXG52YXIgX3Njcm9sbFBhcmVudCA9IHJlcXVpcmUoJy4vdXRpbHMvc2Nyb2xsUGFyZW50Jyk7XG5cbnZhciBfc2Nyb2xsUGFyZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Njcm9sbFBhcmVudCk7XG5cbnZhciBfZGVib3VuY2UgPSByZXF1aXJlKCcuL3V0aWxzL2RlYm91bmNlJyk7XG5cbnZhciBfZGVib3VuY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVib3VuY2UpO1xuXG52YXIgX3Rocm90dGxlID0gcmVxdWlyZSgnLi91dGlscy90aHJvdHRsZScpO1xuXG52YXIgX3Rocm90dGxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Rocm90dGxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHJlYWN0LWxhenlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuXG52YXIgZGVmYXVsdEJvdW5kaW5nQ2xpZW50UmVjdCA9IHsgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG52YXIgTElTVEVOX0ZMQUcgPSAnZGF0YS1sYXp5bG9hZC1saXN0ZW5lZCc7XG52YXIgbGlzdGVuZXJzID0gW107XG52YXIgcGVuZGluZyA9IFtdO1xuXG4vLyB0cnkgdG8gaGFuZGxlIHBhc3NpdmUgZXZlbnRzXG52YXIgcGFzc2l2ZUV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG50cnkge1xuICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBwYXNzaXZlRXZlbnRTdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XG59IGNhdGNoIChlKSB7fVxuLy8gaWYgdGhleSBhcmUgc3VwcG9ydGVkLCBzZXR1cCB0aGUgb3B0aW9uYWwgcGFyYW1zXG4vLyBJTVBPUlRBTlQ6IEZBTFNFIGRvdWJsZXMgYXMgdGhlIGRlZmF1bHQgQ0FQVFVSRSB2YWx1ZSFcbnZhciBwYXNzaXZlRXZlbnQgPSBwYXNzaXZlRXZlbnRTdXBwb3J0ZWQgPyB7IGNhcHR1cmU6IGZhbHNlLCBwYXNzaXZlOiB0cnVlIH0gOiBmYWxzZTtcblxuLyoqXG4gKiBDaGVjayBpZiBgY29tcG9uZW50YCBpcyB2aXNpYmxlIGluIG92ZXJmbG93IGNvbnRhaW5lciBgcGFyZW50YFxuICogQHBhcmFtICB7bm9kZX0gY29tcG9uZW50IFJlYWN0IGNvbXBvbmVudFxuICogQHBhcmFtICB7bm9kZX0gcGFyZW50ICAgIGNvbXBvbmVudCdzIHNjcm9sbCBwYXJlbnRcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cbnZhciBjaGVja092ZXJmbG93VmlzaWJsZSA9IGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3dWaXNpYmxlKGNvbXBvbmVudCwgcGFyZW50KSB7XG4gIHZhciBub2RlID0gX3JlYWN0RG9tMi5kZWZhdWx0LmZpbmRET01Ob2RlKGNvbXBvbmVudCk7XG4gIC8vIGNvbnN0IG5vZGUgPSBjb21wb25lbnQucmVmO1xuXG4gIHZhciBwYXJlbnRUb3AgPSB2b2lkIDA7XG4gIHZhciBwYXJlbnRMZWZ0ID0gdm9pZCAwO1xuICB2YXIgcGFyZW50SGVpZ2h0ID0gdm9pZCAwO1xuICB2YXIgcGFyZW50V2lkdGggPSB2b2lkIDA7XG5cbiAgdHJ5IHtcbiAgICB2YXIgX3BhcmVudCRnZXRCb3VuZGluZ0NsID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgcGFyZW50VG9wID0gX3BhcmVudCRnZXRCb3VuZGluZ0NsLnRvcDtcbiAgICBwYXJlbnRMZWZ0ID0gX3BhcmVudCRnZXRCb3VuZGluZ0NsLmxlZnQ7XG4gICAgcGFyZW50SGVpZ2h0ID0gX3BhcmVudCRnZXRCb3VuZGluZ0NsLmhlaWdodDtcbiAgICBwYXJlbnRXaWR0aCA9IF9wYXJlbnQkZ2V0Qm91bmRpbmdDbC53aWR0aDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHBhcmVudFRvcCA9IGRlZmF1bHRCb3VuZGluZ0NsaWVudFJlY3QudG9wO1xuICAgIHBhcmVudExlZnQgPSBkZWZhdWx0Qm91bmRpbmdDbGllbnRSZWN0LmxlZnQ7XG4gICAgcGFyZW50SGVpZ2h0ID0gZGVmYXVsdEJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQ7XG4gICAgcGFyZW50V2lkdGggPSBkZWZhdWx0Qm91bmRpbmdDbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgdmFyIHdpbmRvd0lubmVySGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHZhciB3aW5kb3dJbm5lcldpZHRoID0gd2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuXG4gIC8vIGNhbGN1bGF0ZSB0b3AgYW5kIGhlaWdodCBvZiB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSBlbGVtZW50J3Mgc2Nyb2xsUGFyZW50IGFuZCB2aWV3cG9ydFxuICB2YXIgaW50ZXJzZWN0aW9uVG9wID0gTWF0aC5tYXgocGFyZW50VG9wLCAwKTsgLy8gaW50ZXJzZWN0aW9uJ3MgdG9wIHJlbGF0aXZlIHRvIHZpZXdwb3J0XG4gIHZhciBpbnRlcnNlY3Rpb25MZWZ0ID0gTWF0aC5tYXgocGFyZW50TGVmdCwgMCk7IC8vIGludGVyc2VjdGlvbidzIGxlZnQgcmVsYXRpdmUgdG8gdmlld3BvcnRcbiAgdmFyIGludGVyc2VjdGlvbkhlaWdodCA9IE1hdGgubWluKHdpbmRvd0lubmVySGVpZ2h0LCBwYXJlbnRUb3AgKyBwYXJlbnRIZWlnaHQpIC0gaW50ZXJzZWN0aW9uVG9wOyAvLyBoZWlnaHRcbiAgdmFyIGludGVyc2VjdGlvbldpZHRoID0gTWF0aC5taW4od2luZG93SW5uZXJXaWR0aCwgcGFyZW50TGVmdCArIHBhcmVudFdpZHRoKSAtIGludGVyc2VjdGlvbkxlZnQ7IC8vIHdpZHRoXG5cbiAgLy8gY2hlY2sgd2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIHRoZSBpbnRlcnNlY3Rpb25cbiAgdmFyIHRvcCA9IHZvaWQgMDtcbiAgdmFyIGxlZnQgPSB2b2lkIDA7XG4gIHZhciBoZWlnaHQgPSB2b2lkIDA7XG4gIHZhciB3aWR0aCA9IHZvaWQgMDtcblxuICB0cnkge1xuICAgIHZhciBfbm9kZSRnZXRCb3VuZGluZ0NsaWUgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgdG9wID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLnRvcDtcbiAgICBsZWZ0ID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLmxlZnQ7XG4gICAgaGVpZ2h0ID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLmhlaWdodDtcbiAgICB3aWR0aCA9IF9ub2RlJGdldEJvdW5kaW5nQ2xpZS53aWR0aDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRvcCA9IGRlZmF1bHRCb3VuZGluZ0NsaWVudFJlY3QudG9wO1xuICAgIGxlZnQgPSBkZWZhdWx0Qm91bmRpbmdDbGllbnRSZWN0LmxlZnQ7XG4gICAgaGVpZ2h0ID0gZGVmYXVsdEJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQ7XG4gICAgd2lkdGggPSBkZWZhdWx0Qm91bmRpbmdDbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgdmFyIG9mZnNldFRvcCA9IHRvcCAtIGludGVyc2VjdGlvblRvcDsgLy8gZWxlbWVudCdzIHRvcCByZWxhdGl2ZSB0byBpbnRlcnNlY3Rpb25cbiAgdmFyIG9mZnNldExlZnQgPSBsZWZ0IC0gaW50ZXJzZWN0aW9uTGVmdDsgLy8gZWxlbWVudCdzIGxlZnQgcmVsYXRpdmUgdG8gaW50ZXJzZWN0aW9uXG5cbiAgdmFyIG9mZnNldHMgPSBBcnJheS5pc0FycmF5KGNvbXBvbmVudC5wcm9wcy5vZmZzZXQpID8gY29tcG9uZW50LnByb3BzLm9mZnNldCA6IFtjb21wb25lbnQucHJvcHMub2Zmc2V0LCBjb21wb25lbnQucHJvcHMub2Zmc2V0XTsgLy8gQmUgY29tcGF0aWJsZSB3aXRoIHByZXZpb3VzIEFQSVxuXG4gIHJldHVybiBvZmZzZXRUb3AgLSBvZmZzZXRzWzBdIDw9IGludGVyc2VjdGlvbkhlaWdodCAmJiBvZmZzZXRUb3AgKyBoZWlnaHQgKyBvZmZzZXRzWzFdID49IDAgJiYgb2Zmc2V0TGVmdCAtIG9mZnNldHNbMF0gPD0gaW50ZXJzZWN0aW9uV2lkdGggJiYgb2Zmc2V0TGVmdCArIHdpZHRoICsgb2Zmc2V0c1sxXSA+PSAwO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgY29tcG9uZW50YCBpcyB2aXNpYmxlIGluIGRvY3VtZW50XG4gKiBAcGFyYW0gIHtub2RlfSBjb21wb25lbnQgUmVhY3QgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtib29sfVxuICovXG52YXIgY2hlY2tOb3JtYWxWaXNpYmxlID0gZnVuY3Rpb24gY2hlY2tOb3JtYWxWaXNpYmxlKGNvbXBvbmVudCkge1xuICB2YXIgbm9kZSA9IF9yZWFjdERvbTIuZGVmYXVsdC5maW5kRE9NTm9kZShjb21wb25lbnQpO1xuICAvLyBjb25zdCBub2RlID0gY29tcG9uZW50LnJlZjtcblxuICAvLyBJZiB0aGlzIGVsZW1lbnQgaXMgaGlkZGVuIGJ5IGNzcyBydWxlcyBzb21laG93LCBpdCdzIGRlZmluaXRlbHkgaW52aXNpYmxlXG4gIGlmICghKG5vZGUub2Zmc2V0V2lkdGggfHwgbm9kZS5vZmZzZXRIZWlnaHQgfHwgbm9kZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCkpIHJldHVybiBmYWxzZTtcblxuICB2YXIgdG9wID0gdm9pZCAwO1xuICB2YXIgZWxlbWVudEhlaWdodCA9IHZvaWQgMDtcblxuICB0cnkge1xuICAgIHZhciBfbm9kZSRnZXRCb3VuZGluZ0NsaWUyID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHRvcCA9IF9ub2RlJGdldEJvdW5kaW5nQ2xpZTIudG9wO1xuICAgIGVsZW1lbnRIZWlnaHQgPSBfbm9kZSRnZXRCb3VuZGluZ0NsaWUyLmhlaWdodDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRvcCA9IGRlZmF1bHRCb3VuZGluZ0NsaWVudFJlY3QudG9wO1xuICAgIGVsZW1lbnRIZWlnaHQgPSBkZWZhdWx0Qm91bmRpbmdDbGllbnRSZWN0LmhlaWdodDtcbiAgfVxuXG4gIHZhciB3aW5kb3dJbm5lckhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuXG4gIHZhciBvZmZzZXRzID0gQXJyYXkuaXNBcnJheShjb21wb25lbnQucHJvcHMub2Zmc2V0KSA/IGNvbXBvbmVudC5wcm9wcy5vZmZzZXQgOiBbY29tcG9uZW50LnByb3BzLm9mZnNldCwgY29tcG9uZW50LnByb3BzLm9mZnNldF07IC8vIEJlIGNvbXBhdGlibGUgd2l0aCBwcmV2aW91cyBBUElcblxuICByZXR1cm4gdG9wIC0gb2Zmc2V0c1swXSA8PSB3aW5kb3dJbm5lckhlaWdodCAmJiB0b3AgKyBlbGVtZW50SGVpZ2h0ICsgb2Zmc2V0c1sxXSA+PSAwO1xufTtcblxuLyoqXG4gKiBEZXRlY3QgaWYgZWxlbWVudCBpcyB2aXNpYmxlIGluIHZpZXdwb3J0LCBpZiBzbywgc2V0IGB2aXNpYmxlYCBzdGF0ZSB0byB0cnVlLlxuICogSWYgYG9uY2VgIHByb3AgaXMgcHJvdmlkZWQgdHJ1ZSwgcmVtb3ZlIGNvbXBvbmVudCBhcyBsaXN0ZW5lciBhZnRlciBjaGVja1Zpc2libGVcbiAqXG4gKiBAcGFyYW0gIHtSZWFjdH0gY29tcG9uZW50ICAgUmVhY3QgY29tcG9uZW50IHRoYXQgcmVzcG9uZCB0byBzY3JvbGwgYW5kIHJlc2l6ZVxuICovXG52YXIgY2hlY2tWaXNpYmxlID0gZnVuY3Rpb24gY2hlY2tWaXNpYmxlKGNvbXBvbmVudCkge1xuICB2YXIgbm9kZSA9IF9yZWFjdERvbTIuZGVmYXVsdC5maW5kRE9NTm9kZShjb21wb25lbnQpO1xuICAvLyBjb25zdCBub2RlID0gY29tcG9uZW50LnJlZjtcbiAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYXJlbnQgPSAoMCwgX3Njcm9sbFBhcmVudDIuZGVmYXVsdCkobm9kZSk7XG4gIHZhciBpc092ZXJmbG93ID0gY29tcG9uZW50LnByb3BzLm92ZXJmbG93ICYmIHBhcmVudCAhPT0gbm9kZS5vd25lckRvY3VtZW50ICYmIHBhcmVudCAhPT0gZG9jdW1lbnQgJiYgcGFyZW50ICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciB2aXNpYmxlID0gaXNPdmVyZmxvdyA/IGNoZWNrT3ZlcmZsb3dWaXNpYmxlKGNvbXBvbmVudCwgcGFyZW50KSA6IGNoZWNrTm9ybWFsVmlzaWJsZShjb21wb25lbnQpO1xuICBpZiAodmlzaWJsZSkge1xuICAgIC8vIEF2b2lkIGV4dHJhIHJlbmRlciBpZiBwcmV2aW91c2x5IGlzIHZpc2libGVcbiAgICBpZiAoIWNvbXBvbmVudC52aXNpYmxlKSB7XG4gICAgICBpZiAoY29tcG9uZW50LnByb3BzLm9uY2UpIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICB9XG5cbiAgICAgIGNvbXBvbmVudC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIGNvbXBvbmVudC5mb3JjZVVwZGF0ZSgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghKGNvbXBvbmVudC5wcm9wcy5vbmNlICYmIGNvbXBvbmVudC52aXNpYmxlKSkge1xuICAgIGNvbXBvbmVudC52aXNpYmxlID0gZmFsc2U7XG4gICAgaWYgKGNvbXBvbmVudC5wcm9wcy51bm1vdW50SWZJbnZpc2libGUpIHtcbiAgICAgIGNvbXBvbmVudC5mb3JjZVVwZGF0ZSgpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHB1cmdlUGVuZGluZyA9IGZ1bmN0aW9uIHB1cmdlUGVuZGluZygpIHtcbiAgcGVuZGluZy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihjb21wb25lbnQpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfSk7XG5cbiAgcGVuZGluZyA9IFtdO1xufTtcblxudmFyIGxhenlMb2FkSGFuZGxlciA9IGZ1bmN0aW9uIGxhenlMb2FkSGFuZGxlcigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgY2hlY2tWaXNpYmxlKGxpc3RlbmVyKTtcbiAgfVxuICAvLyBSZW1vdmUgYG9uY2VgIGNvbXBvbmVudCBpbiBsaXN0ZW5lcnNcbiAgcHVyZ2VQZW5kaW5nKCk7XG59O1xuXG4vKipcbiAqIEZvcmNlcyB0aGUgY29tcG9uZW50IHRvIGRpc3BsYXkgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gdGhlIHZpZXdwb3J0LlxuICovXG52YXIgZm9yY2VWaXNpYmxlID0gZnVuY3Rpb24gZm9yY2VWaXNpYmxlKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICBsaXN0ZW5lci52aXNpYmxlID0gdHJ1ZTtcbiAgICBsaXN0ZW5lci5mb3JjZVVwZGF0ZSgpO1xuICB9XG4gIC8vIFJlbW92ZSBgb25jZWAgY29tcG9uZW50IGluIGxpc3RlbmVyc1xuICBwdXJnZVBlbmRpbmcoKTtcbn07XG5cbi8vIERlcGVuZGluZyBvbiBjb21wb25lbnQncyBwcm9wc1xudmFyIGRlbGF5VHlwZSA9IHZvaWQgMDtcbnZhciBmaW5hbExhenlMb2FkSGFuZGxlciA9IG51bGw7XG5cbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHN0cmluZykge1xuICByZXR1cm4gdHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZyc7XG59O1xuXG52YXIgTGF6eUxvYWQgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTGF6eUxvYWQsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIExhenlMb2FkKHByb3BzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExhenlMb2FkKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChMYXp5TG9hZC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExhenlMb2FkKSkuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgX3RoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgIC8vIHRoaXMuc2V0UmVmID0gdGhpcy5zZXRSZWYuYmluZCh0aGlzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvLyBzZXRSZWYoZWxlbWVudCkge1xuICAvLyAgIGlmIChlbGVtZW50KSB7XG4gIC8vICAgICB0aGlzLnJlZiA9IGVsZW1lbnQ7XG4gIC8vICAgfVxuICAvLyB9XG5cbiAgX2NyZWF0ZUNsYXNzKExhenlMb2FkLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudERpZE1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAvLyBJdCdzIHVubGlrZWx5IHRvIGNoYW5nZSBkZWxheSB0eXBlIG9uIHRoZSBmbHksIHRoaXMgaXMgbWFpbmx5XG4gICAgICAvLyBkZXNpZ25lZCBmb3IgdGVzdHNcbiAgICAgIHZhciBzY3JvbGxwb3J0ID0gd2luZG93O1xuICAgICAgdmFyIHNjcm9sbENvbnRhaW5lciA9IHRoaXMucHJvcHMuc2Nyb2xsQ29udGFpbmVyO1xuXG4gICAgICBpZiAoc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICAgIGlmIChpc1N0cmluZyhzY3JvbGxDb250YWluZXIpKSB7XG4gICAgICAgICAgc2Nyb2xscG9ydCA9IHNjcm9sbHBvcnQuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzY3JvbGxDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbmVlZFJlc2V0RmluYWxMYXp5TG9hZEhhbmRsZXIgPSB0aGlzLnByb3BzLmRlYm91bmNlICE9PSB1bmRlZmluZWQgJiYgZGVsYXlUeXBlID09PSAndGhyb3R0bGUnIHx8IGRlbGF5VHlwZSA9PT0gJ2RlYm91bmNlJyAmJiB0aGlzLnByb3BzLmRlYm91bmNlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZWVkUmVzZXRGaW5hbExhenlMb2FkSGFuZGxlcikge1xuICAgICAgICAoMCwgX2V2ZW50Lm9mZikoc2Nyb2xscG9ydCwgJ3Njcm9sbCcsIGZpbmFsTGF6eUxvYWRIYW5kbGVyLCBwYXNzaXZlRXZlbnQpO1xuICAgICAgICAoMCwgX2V2ZW50Lm9mZikod2luZG93LCAncmVzaXplJywgZmluYWxMYXp5TG9hZEhhbmRsZXIsIHBhc3NpdmVFdmVudCk7XG4gICAgICAgIGZpbmFsTGF6eUxvYWRIYW5kbGVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmaW5hbExhenlMb2FkSGFuZGxlcikge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5kZWJvdW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZmluYWxMYXp5TG9hZEhhbmRsZXIgPSAoMCwgX2RlYm91bmNlMi5kZWZhdWx0KShsYXp5TG9hZEhhbmRsZXIsIHR5cGVvZiB0aGlzLnByb3BzLmRlYm91bmNlID09PSAnbnVtYmVyJyA/IHRoaXMucHJvcHMuZGVib3VuY2UgOiAzMDApO1xuICAgICAgICAgIGRlbGF5VHlwZSA9ICdkZWJvdW5jZSc7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy50aHJvdHRsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZmluYWxMYXp5TG9hZEhhbmRsZXIgPSAoMCwgX3Rocm90dGxlMi5kZWZhdWx0KShsYXp5TG9hZEhhbmRsZXIsIHR5cGVvZiB0aGlzLnByb3BzLnRocm90dGxlID09PSAnbnVtYmVyJyA/IHRoaXMucHJvcHMudGhyb3R0bGUgOiAzMDApO1xuICAgICAgICAgIGRlbGF5VHlwZSA9ICd0aHJvdHRsZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmluYWxMYXp5TG9hZEhhbmRsZXIgPSBsYXp5TG9hZEhhbmRsZXI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJvcHMub3ZlcmZsb3cpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9ICgwLCBfc2Nyb2xsUGFyZW50Mi5kZWZhdWx0KShfcmVhY3REb20yLmRlZmF1bHQuZmluZERPTU5vZGUodGhpcykpO1xuICAgICAgICAvLyBjb25zdCBwYXJlbnQgPSBzY3JvbGxQYXJlbnQodGhpcy5yZWYpO1xuICAgICAgICBpZiAocGFyZW50ICYmIHR5cGVvZiBwYXJlbnQuZ2V0QXR0cmlidXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGxpc3RlbmVyQ291bnQgPSAxICsgK3BhcmVudC5nZXRBdHRyaWJ1dGUoTElTVEVOX0ZMQUcpO1xuICAgICAgICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICBwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZmluYWxMYXp5TG9hZEhhbmRsZXIsIHBhc3NpdmVFdmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudC5zZXRBdHRyaWJ1dGUoTElTVEVOX0ZMQUcsIGxpc3RlbmVyQ291bnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDAgfHwgbmVlZFJlc2V0RmluYWxMYXp5TG9hZEhhbmRsZXIpIHtcbiAgICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBzY3JvbGwgPSBfcHJvcHMuc2Nyb2xsLFxuICAgICAgICAgICAgcmVzaXplID0gX3Byb3BzLnJlc2l6ZTtcblxuXG4gICAgICAgIGlmIChzY3JvbGwpIHtcbiAgICAgICAgICAoMCwgX2V2ZW50Lm9uKShzY3JvbGxwb3J0LCAnc2Nyb2xsJywgZmluYWxMYXp5TG9hZEhhbmRsZXIsIHBhc3NpdmVFdmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzaXplKSB7XG4gICAgICAgICAgKDAsIF9ldmVudC5vbikod2luZG93LCAncmVzaXplJywgZmluYWxMYXp5TG9hZEhhbmRsZXIsIHBhc3NpdmVFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzLnB1c2godGhpcyk7XG4gICAgICBjaGVja1Zpc2libGUodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsVW5tb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMub3ZlcmZsb3cpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9ICgwLCBfc2Nyb2xsUGFyZW50Mi5kZWZhdWx0KShfcmVhY3REb20yLmRlZmF1bHQuZmluZERPTU5vZGUodGhpcykpO1xuICAgICAgICAvLyBjb25zdCBwYXJlbnQgPSBzY3JvbGxQYXJlbnQodGhpcy5yZWYpO1xuICAgICAgICBpZiAocGFyZW50ICYmIHR5cGVvZiBwYXJlbnQuZ2V0QXR0cmlidXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGxpc3RlbmVyQ291bnQgPSArcGFyZW50LmdldEF0dHJpYnV0ZShMSVNURU5fRkxBRykgLSAxO1xuICAgICAgICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZmluYWxMYXp5TG9hZEhhbmRsZXIsIHBhc3NpdmVFdmVudCk7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQXR0cmlidXRlKExJU1RFTl9GTEFHKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50LnNldEF0dHJpYnV0ZShMSVNURU5fRkxBRywgbGlzdGVuZXJDb3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKHRoaXMpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDAgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgKDAsIF9ldmVudC5vZmYpKHdpbmRvdywgJ3Jlc2l6ZScsIGZpbmFsTGF6eUxvYWRIYW5kbGVyLCBwYXNzaXZlRXZlbnQpO1xuICAgICAgICAoMCwgX2V2ZW50Lm9mZikod2luZG93LCAnc2Nyb2xsJywgZmluYWxMYXp5TG9hZEhhbmRsZXIsIHBhc3NpdmVFdmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZSA/IHRoaXMucHJvcHMuY2hpbGRyZW4gOiB0aGlzLnByb3BzLnBsYWNlaG9sZGVyID8gdGhpcy5wcm9wcy5wbGFjZWhvbGRlciA6IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7IHN0eWxlOiB7IGhlaWdodDogdGhpcy5wcm9wcy5oZWlnaHQgfSwgY2xhc3NOYW1lOiAnbGF6eWxvYWQtcGxhY2Vob2xkZXInIH0pO1xuICAgICAgLy8gPHNwYW4gcmVmPXt0aGlzLnNldFJlZn0gY2xhc3NOYW1lPVwibGF6eWxvYWQtY3VzdG9tLXBsYWNlaG9sZGVyXCI+XG4gICAgICAvLyAgIHt0aGlzLnByb3BzLnBsYWNlaG9sZGVyfVxuICAgICAgLy8gPC9zcGFuPiA6XG4gICAgICAvLyA8ZGl2IHJlZj17dGhpcy5zZXRSZWZ9IHN0eWxlPXt7IGhlaWdodDogdGhpcy5wcm9wcy5oZWlnaHQgfX0gY2xhc3NOYW1lPVwibGF6eWxvYWQtcGxhY2Vob2xkZXJcIiAvPjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGF6eUxvYWQ7XG59KF9yZWFjdC5Db21wb25lbnQpO1xuXG5MYXp5TG9hZC5wcm9wVHlwZXMgPSB7XG4gIG9uY2U6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgaGVpZ2h0OiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsIF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nXSksXG4gIG9mZnNldDogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLCBfcHJvcFR5cGVzMi5kZWZhdWx0LmFycmF5T2YoX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIpXSksXG4gIG92ZXJmbG93OiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG4gIHJlc2l6ZTogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuICBzY3JvbGw6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgY2hpbGRyZW46IF9wcm9wVHlwZXMyLmRlZmF1bHQubm9kZSxcbiAgdGhyb3R0bGU6IF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlciwgX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sXSksXG4gIGRlYm91bmNlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsIF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbF0pLFxuICBwbGFjZWhvbGRlcjogX3Byb3BUeXBlczIuZGVmYXVsdC5ub2RlLFxuICBzY3JvbGxDb250YWluZXI6IF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZywgX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3RdKSxcbiAgdW5tb3VudElmSW52aXNpYmxlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2xcbn07XG5cbkxhenlMb2FkLmRlZmF1bHRQcm9wcyA9IHtcbiAgb25jZTogZmFsc2UsXG4gIG9mZnNldDogMCxcbiAgb3ZlcmZsb3c6IGZhbHNlLFxuICByZXNpemU6IGZhbHNlLFxuICBzY3JvbGw6IHRydWUsXG4gIHVubW91bnRJZkludmlzaWJsZTogZmFsc2Vcbn07XG5cbnZhciBnZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpIHtcbiAgcmV0dXJuIFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xufTtcblxudmFyIGRlY29yYXRvciA9IGZ1bmN0aW9uIGRlY29yYXRvcigpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbGF6eWxvYWQoV3JhcHBlZENvbXBvbmVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoX0NvbXBvbmVudDIpIHtcbiAgICAgIF9pbmhlcml0cyhMYXp5TG9hZERlY29yYXRlZCwgX0NvbXBvbmVudDIpO1xuXG4gICAgICBmdW5jdGlvbiBMYXp5TG9hZERlY29yYXRlZCgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExhenlMb2FkRGVjb3JhdGVkKTtcblxuICAgICAgICB2YXIgX3RoaXMyID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKExhenlMb2FkRGVjb3JhdGVkLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGF6eUxvYWREZWNvcmF0ZWQpKS5jYWxsKHRoaXMpKTtcblxuICAgICAgICBfdGhpczIuZGlzcGxheU5hbWUgPSAnTGF6eUxvYWQnICsgZ2V0RGlzcGxheU5hbWUoV3JhcHBlZENvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiBfdGhpczI7XG4gICAgICB9XG5cbiAgICAgIF9jcmVhdGVDbGFzcyhMYXp5TG9hZERlY29yYXRlZCwgW3tcbiAgICAgICAga2V5OiAncmVuZGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBMYXp5TG9hZCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCB0aGlzLnByb3BzKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIExhenlMb2FkRGVjb3JhdGVkO1xuICAgIH0oX3JlYWN0LkNvbXBvbmVudCk7XG4gIH07XG59O1xuXG5leHBvcnRzLmxhenlsb2FkID0gZGVjb3JhdG9yO1xuZXhwb3J0cy5kZWZhdWx0ID0gTGF6eUxvYWQ7XG5leHBvcnRzLmZvcmNlQ2hlY2sgPSBsYXp5TG9hZEhhbmRsZXI7XG5leHBvcnRzLmZvcmNlVmlzaWJsZSA9IGZvcmNlVmlzaWJsZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlYm91bmNlO1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gIHZhciB0aW1lb3V0ID0gdm9pZCAwO1xuICB2YXIgYXJncyA9IHZvaWQgMDtcbiAgdmFyIGNvbnRleHQgPSB2b2lkIDA7XG4gIHZhciB0aW1lc3RhbXAgPSB2b2lkIDA7XG4gIHZhciByZXN1bHQgPSB2b2lkIDA7XG5cbiAgdmFyIGxhdGVyID0gZnVuY3Rpb24gbGF0ZXIoKSB7XG4gICAgdmFyIGxhc3QgPSArbmV3IERhdGUoKSAtIHRpbWVzdGFtcDtcblxuICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgICAgY29udGV4dCA9IG51bGw7XG4gICAgICAgICAgYXJncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICBjb250ZXh0ID0gdGhpcztcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHRpbWVzdGFtcCA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgfVxuXG4gICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjb250ZXh0ID0gbnVsbDtcbiAgICAgIGFyZ3MgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm9uID0gb247XG5leHBvcnRzLm9mZiA9IG9mZjtcbmZ1bmN0aW9uIG9uKGVsLCBldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IGZhbHNlO1xuICBpZiAoZWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0cyk7XG4gIH0gZWxzZSBpZiAoZWwuYXR0YWNoRXZlbnQpIHtcbiAgICBlbC5hdHRhY2hFdmVudChcIm9uXCIgKyBldmVudE5hbWUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGVsLCBlIHx8IHdpbmRvdy5ldmVudCk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb2ZmKGVsLCBldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IGZhbHNlO1xuICBpZiAoZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0cyk7XG4gIH0gZWxzZSBpZiAoZWwuZGV0YWNoRXZlbnQpIHtcbiAgICBlbC5kZXRhY2hFdmVudChcIm9uXCIgKyBldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgfVxufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IEZpbmQgc2Nyb2xsIHBhcmVudFxuICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICghKG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgdmFyIGV4Y2x1ZGVTdGF0aWNQYXJlbnQgPSBub2RlLnN0eWxlLnBvc2l0aW9uID09PSAnYWJzb2x1dGUnO1xuICB2YXIgb3ZlcmZsb3dSZWdleCA9IC8oc2Nyb2xsfGF1dG8pLztcbiAgdmFyIHBhcmVudCA9IG5vZGU7XG5cbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmICghcGFyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudCk7XG4gICAgdmFyIHBvc2l0aW9uID0gc3R5bGUucG9zaXRpb247XG4gICAgdmFyIG92ZXJmbG93ID0gc3R5bGUub3ZlcmZsb3c7XG4gICAgdmFyIG92ZXJmbG93WCA9IHN0eWxlWydvdmVyZmxvdy14J107XG4gICAgdmFyIG92ZXJmbG93WSA9IHN0eWxlWydvdmVyZmxvdy15J107XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdzdGF0aWMnICYmIGV4Y2x1ZGVTdGF0aWNQYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG92ZXJmbG93UmVnZXgudGVzdChvdmVyZmxvdykgJiYgb3ZlcmZsb3dSZWdleC50ZXN0KG92ZXJmbG93WCkgJiYgb3ZlcmZsb3dSZWdleC50ZXN0KG92ZXJmbG93WSkpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0aHJvdHRsZTtcbi8qZXNsaW50LWRpc2FibGUgKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZuLCB0aHJlc2hob2xkLCBzY29wZSkge1xuICB0aHJlc2hob2xkIHx8ICh0aHJlc2hob2xkID0gMjUwKTtcbiAgdmFyIGxhc3QsIGRlZmVyVGltZXI7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRleHQgPSBzY29wZSB8fCB0aGlzO1xuXG4gICAgdmFyIG5vdyA9ICtuZXcgRGF0ZSgpLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIGlmIChsYXN0ICYmIG5vdyA8IGxhc3QgKyB0aHJlc2hob2xkKSB7XG4gICAgICAvLyBob2xkIG9uIHRvIGl0XG4gICAgICBjbGVhclRpbWVvdXQoZGVmZXJUaW1lcik7XG4gICAgICBkZWZlclRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxhc3QgPSBub3c7XG4gICAgICAgIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgfSwgdGhyZXNoaG9sZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBub3c7XG4gICAgICBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9XG4gIH07XG59Il0sInNvdXJjZVJvb3QiOiIifQ==